---
title: 백엔드 개발자 면접 질문 정리(2)
categories:
  - Dev
tags:
  - backend interviews
  - http
  - firewall
  - docker
  - virtual machine
  - cpu
last_modified_at: 2023-06-26T21:30:00-00:00
---



## 백엔드 개발자 면접 예상 질문 및 주요개념을 정리해보았습니다.

---


## HTTP/2의 특징은?

HTTP/2 는 World Wide Web에서 사용되는 HTTP 네트워크 프로토콜의 주요 개정판이다. Internet Engineering Task Force의 HTTP 작업 그룹에서 개발했다. HTTP/2는 HTTP/1.1에 이어 2015년에 처음 표준화되었다. HTTP/1.1에 비해 몇 가지 주요 기능과 개선사항이 있다.

### 바이너리 프로토콜

HTTP/2 는 텍스트 기반인 이전 HTTP/1.1 과 달리 바이너리 프로토콜. 이렇게 하면 HTTP/2가 더 강력하고 효율적이며 구문 분석하기 쉬워진다. 바이너리 프로토콜은 요청 및 응답에 컴팩트하고 고정된 형식을 사용하기 때문에 오류가 덜 발생하고 오버헤드도 줄인다.

### 멀티플렉싱

HTTP/1.1에서 브라우저는 여러 요청을 동시에 보내기 위해 여러 TCP 연결을 열어 비효율적이다. HTTP/2는 동일한 TCP 연결에서 여러 요청과 응답을 동시에 보낼 수 있는 다중화를 도입한다. 이는 대기 시간을 줄이고 데이터 전송을 효율성을 향상시킨다.

HTTP/1.1에서 각 요청-응답 쌍에는 별도의 TCP 연결이 필요했습니다. 이것은 TCP 연결을 설정하는 데 시간과 자원이 많이 소요되고 각 연결이 한 번에 하나의 요청-응답만 수행할 수 있기 때문에 비효율적이었습니다(헤드 오브 라인 블로킹으로 알려진 문제)

HTTP/2는 이러한 문제를 해결하기 위해 다중화를 도입했습니다. HTTP/2의 다중화는 HTTP 페이로드를 각각 스트림 식별자로 태그가 지정된 개별 프레임으로 나누어 작동합니다. 모든 프레임은 단일 TCP 연결을 통해 전송됩니다.

**스트림:** HTTP/2에서 각 요청-응답 쌍을 "스트림"이라고 합니다. 각 스트림에는 고유 식별자가 부여됩니다.

**프레임:** 각 스트림은 여러 "프레임"으로 나뉩니다. 프레임은 HTTP/2에서 가장 작은 통신 단위이며 각 프레임은 특정 스트림에 속합니다.

**단일 TCP 연결:** 다른 스트림에 속할 수 있는 이 프레임은 단일 TCP 연결을 통해 전송됩니다. 연결의 프레임 순서는 혼합될 수 있습니다. 원래 스트림의 순서를 따를 필요가 없습니다.

**다른 쪽 끝에서 재조립:** 프레임이 목적지에 도착하면 스트림 식별자를 기반으로 재조립됩니다. 이를 통해 수신자는 원래 요청 및 응답을 재구성할 수 있습니다.

### 헤더 압축

HTTP/2 는 오버헤드를 줄이기 위한 새로운 알고리즘인 HPACK 압축을 도입했다. HTTP/1.1 에서 헤더는 일반 텍스트로 전송되며 크기가 상당히 클 수 있다. HPACK을 사용하면 헤더가 압축되어 특히 콘텐츠 양이 많은 웹사이트의 경우 전송되는 데이터의 양을 크게 줄일 수 있습니다.

### 서버푸시

HTTP/2에는 서버 푸시라는 기능이 있어 서버가 리소스를 클라이언트의 캐시로 미리 보낼 수 있습니다. 즉, 서버는 클라이언트가 실제로 요청하기 전에 클라이언트가 필요로 할 것이라고 예측한 리소스를 보낼 수 있습니다. 이렇게 하면 웹 페이지 로딩 속도가 크게 빨라질 수 있습니다.

### **스트림 우선 순위 지정**

HTTP/2를 사용하면 클라이언트가 다른 요청의 우선 순위를 지정할 수 있습니다. 이렇게 하면 웹 페이지의 보이는 콘텐츠를 로드하는 것과 같은 중요한 요청은 더 빨리 발생하고 오프스크린 이미지 로드와 같은 덜 중요한 요청은 나중에 발생할 수 있습니다.

### **흐름 제어**

HTTP/2를 사용하면 클라이언트와 서버가 서로 수신하는 데이터의 양을 제어하여 발신자가 수신자를 압도하지 않도록 할 수 있습니다. 이 스트림별 흐름 제어 메커니즘은 우선 순위가 높은 스트림이 우선 순위가 낮은 스트림 뒤에서 차단되는 시나리오에서 유용합니다.



## Firewall의 동작 원리는?

방화벽은 미리 정해진 보안 규칙에 따라 들어오고 나가는 네트워크 트래픽을 모니터링하고 제어하는 네트워크 보안 시스템입니다. 본질적으로 신뢰할 수 있는 네트워크와 신뢰할 수 없는 네트워크(예: 인터넷) 사이의 장벽 역할을 하며 보안 규칙에 따라 특정 트래픽을 허용할지 또는 차단할지 결정합니다.

다음은 방화벽 작동 방식에 대한 간단한 설명입니다.

**패킷 검사** 
데이터가 네트워크에 들어오거나 나갈 때 패킷이라는 작은 조각으로 포장됩니다. 방화벽은 이러한 패킷을 검사하여 소스, 대상 및 연결된 응용 프로그램 또는 프로토콜 유형을 결정합니다.

**규칙 기반 의사 결정** 
패킷을 검사한 후 방화벽은 규칙 집합(액세스 제어 목록 또는 ACL이라고도 함)에 따라 결정을 내립니다. 이러한 규칙은 특정 IP 주소에서 오는 모든 트래픽을 차단하는 것처럼 간단할 수도 있고 하루 중 어떤 시간에 어떤 유형의 트래픽이 허용되는지에 대한 복잡한 규칙일 수도 있습니다.

**트래픽 허용 또는 거부** 
패킷이 통과를 허용해야 한다는 규칙과 일치하는 경우 방화벽은 통과를 허용합니다. 차단되어야 한다는 규칙과 일치하는 경우 방화벽은 패킷을 거부하고 네트워크 진입을 중지합니다.

방화벽은 다양한 유형으로 제공됩니다.

**네트워크 방화벽** 
일반적으로 내부 네트워크와 인터넷 사이의 게이트웨이로 사용됩니다. 외부 위협으로부터 전체 로컬 네트워크를 보호합니다.

**호스트 기반 방화벽**
개별 서버 또는 장치에서 실행되며 해당 시스템 안팎의 네트워크 트래픽을 제어합니다.

**소프트웨어 및 하드웨어 방화벽**
 방화벽은 소프트웨어 응용 프로그램 또는 독립 실행형 하드웨어로 구현할 수 있습니다. 소프트웨어 방화벽은 일반적으로 더 유연하고 사용자 지정하기 쉬운 반면 하드웨어 방화벽은 종종 더 나은 성능과 안정성을 제공합니다.

**상태 저장 방화벽** 
이러한 방화벽은 개별 패킷을 검사할 뿐만 아니라 진행 중인 연결을 추적합니다. 이를 통해 네트워크 패킷의 컨텍스트를 이해할 수 있습니다(예: 기존 연결의 일부인지 또는 새 연결을 설정하려는 시도인지 여부).

**애플리케이션 계층 또는 프록시 방화벽** 
이들은 네트워크 프로토콜 스택의 애플리케이션 계층에서 작동합니다. 특정 응용 프로그램 및 프로토콜(예: HTTP 또는 FTP)을 이해할 수 있으며 응용 프로그램이 특정 유형의 정보를 보내거나 받는 것을 방지할 수 있습니다.

**차세대 방화벽(NGFW)** 
암호화된 트래픽 검사, 침입 방지 시스템, 복잡한 공격을 식별하고 차단하는 기능과 같은 추가 기능을 포함하는 고급 방화벽입니다.



## Docker와 Virtual Machine의 차이점은?

Docker와 VM(가상 머신)은 모두 애플리케이션을 실행하기 위해 격리된 환경을 제공하는 기술이지만 근본적으로 다른 방식으로 이를 수행합니다.

**가상 머신**

가상 머신(VM)은 본질적으로 컴퓨터 시스템의 에뮬레이션입니다. 물리적 컴퓨터의 기능을 제공하며 호스트 운영 체제 위에서 전체 운영 체제(OS)를 실행할 수 있습니다.

다음은 VM 아키텍처의 단순화된 표현입니다.

```python
+------------------------------------------+
|                                          |
|  Virtual Machine 1                       |
|  +-----------------+                     |
|  |  App 1          |                     |
|  |  Binaries/Libs  |                     |
|  |  Guest OS       |                     |
|  +-----------------+                     |
|                                          |
|  Virtual Machine 2                       |
|  +-----------------+                     |
|  |  App 2          |                     |
|  |  Binaries/Libs  |                     |
|  |  Guest OS       |                     |
|  +-----------------+                     |
|                                          |
|  Hypervisor                              |
|                                          |
|  Host Operating System                   |
|                                          |
|  Physical Hardware                       |
|                                          |
+------------------------------------------+
```

VM에는 응용 프로그램 바이너리 및 라이브러리와 함께 자체 커널, CPU, 메모리 및 I/O와 같은 시스템 리소스를 포함하는 완전한 OS가 있습니다. VM은 각 인스턴스에 대해 전체 운영 체제를 실행해야 하므로 더 많은 리소스가 필요합니다.

VMM(Virtual Machine Monitor)이라고도 하는 하이퍼바이저는 VM 생성 및 실행을 지원하는 소프트웨어 계층입니다. 호스트 시스템의 하드웨어에서 직접 실행되며 VM을 관리합니다.

**도커(컨테이너)**

반면 Docker는 컨테이너화라는 기술을 활용합니다. 하드웨어 가상화를 제공하는 VM과 달리 컨테이너는 "사용자 공간"을 추상화하여 운영 체제 수준의 가상화를 제공합니다. 여러 Docker 컨테이너가 동일한 OS 커널을 공유할 수 있지만 각 컨테이너는 서로 격리되어 있습니다.

다음은 Docker 아키텍처의 단순화된 표현입니다.

```
+----------------------------------------+
|                                        |
|  Container 1                           |
|  +------------------+                  |
|  |  App 1           |                  |
|  |  Binaries/Libs   |                  |
|  +------------------+                  |
|                                        |
|  Container 2                           |
|  +------------------+                  |
|  |  App 2           |                  |
|  |  Binaries/Libs   |                  |
|  +------------------+                  |
|                                        |
|  Docker Engine                         |
|                                        |
|  Host Operating System                 |
|                                        |
|  Physical Hardware                     |
|                                        |
+----------------------------------------+

```

컨테이너는 호스트 시스템의 커널을 공유하고 시스템 리소스를 보다 효율적으로 사용하므로 VM보다 가볍습니다. 또한 부팅 속도도 더 빠릅니다. Docker 컨테이너는 해당 환경과 함께 애플리케이션을 패키징하므로 동일한 운영 체제를 실행하는 여러 플랫폼 간에 이식성이 뛰어납니다.

요약하면 VM과 Docker는 모두 격리되고 재현 가능한 환경을 제공하지만 서로 다른 장단점이 있는 서로 다른 방식으로 이를 수행합니다.

- VM은 서로 완전히 격리되어 있으며 서로 다른 운영 체제를 실행할 수 있습니다. 그러나 각 VM이 전체 OS를 실행하기 때문에 추가 리소스 비용이 발생합니다.
- Docker 컨테이너는 호스트의 OS 커널을 공유하므로 더 가볍고 효율적입니다. 컨테이너는 동일한 OS 유형에서 격리되고 재현 가능한 환경에 애플리케이션을 배포하는 데 가장 적합합니다.



## AMD와 Intel CPU의 차이점은?

AMD(Advanced Micro Devices)와 Intel은 전 세계에서 가장 큰 CPU 제조업체 중 두 곳입니다. 두 회사 모두 데스크톱 컴퓨터, 랩톱, 서버 및 임베디드 시스템을 포함한 다양한 응용 프로그램용 CPU를 만듭니다. 다음은 둘 사이의 몇 가지 주요 차이점과 고려 사항입니다.

### 1. Architecture

AMD와 Intel 프로세서는 근본적으로 유사한 x86 아키텍처를 기반으로 하지만 서로 다른 수준의 성능과 전력 효율성으로 변환되는 고유한 마이크로 아키텍처를 가지고 있습니다.

- Intel의 Core 시리즈(예: i3, i5, i7, i9) 및 서버용 Xeon 프로세서는 강력한 단일 코어 성능으로 유명합니다. 이는 병렬화에 적합하지 않고 작업을 순차적으로 실행해야 하는 애플리케이션에 중요합니다.
- 반면에 AMD의 Ryzen 및 EPYC 프로세서는 멀티 코어 및 멀티 스레딩 기능으로 찬사를 받았습니다. 이는 최신 소프트웨어 응용 프로그램에서 많이 활용되는 기능인 더 작은 작업으로 나누어 동시에 처리할 수 있는 작업에 특히 유용합니다.

### 2. 통합 그래픽

Intel은 전통적으로 대부분의 CPU에 통합 그래픽을 포함하고 있는데, 이는 빠듯한 예산으로 시스템을 구축하고 개별 그래픽 카드를 추가할 계획이 없는 경우에 유용할 수 있습니다.

반면에 AMD는 통합 그래픽(APU 라인)이 있는 CPU를 제공하지만 많은 고성능 Ryzen CPU에는 이 기능이 없으며 별도의 그래픽 카드가 필요합니다.

### 3. 달러당 성능

AMD는 비슷한 Intel CPU보다 저렴한 가격으로 경쟁력 있는 성능을 제공하는 CPU를 제공하는 예산 친화적인 옵션으로 간주되는 경우가 많습니다. AMD는 또한 동일한 가격대에서 코어 및 스레드 수 측면에서 Intel보다 앞서 있어 뛰어난 멀티 태스킹 및 멀티 스레딩 성능을 제공할 수 있습니다.

### 4. 열 출력 및 전력 소비

인텔 CPU는 전통적으로 더 전력 효율적인 것으로 여겨져 왔지만 특정 모델과 두 회사의 최근 발전에 따라 다를 수 있습니다. 전력 소비가 낮으면 발열이 줄어들고 노트북의 배터리 수명이 길어질 수 있습니다.

### 5. 시장 인식 및 브랜드

오래된 회사인 인텔은 안정성과 신뢰성으로 명성이 높았습니다. 그러나 AMD는 최근 몇 년 동안 성능, 가격 및 안정성 측면에서 경쟁력 있는 제품을 제공하면서 격차를 크게 좁혔습니다.

### 6. 호환성

고려해야 할 호환성 문제도 있습니다. 일부 소프트웨어는 Intel CPU에 더 잘 최적화되어 있는 반면 다른 소프트웨어는 AMD CPU에서 더 잘 수행될 수 있습니다. 그러나 대부분의 일반적인 컴퓨팅 작업 및 소프트웨어의 경우 이러한 차이는 미미한 경우가 많습니다.
