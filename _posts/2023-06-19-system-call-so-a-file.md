---
title: system call 그리고 .so와 .a 파일의 차이
categories:
  - Dev
tags:
  - system
  - call
  - so
  - file
  - interview
last_modified_at: 2023-06-19T23:00:00-00:00
---

시스템 호출은 프로그램이 운영 체제의 핵심인 커널에 서비스를 요청할 수 있도록 운영 체제에서 제공하는 메커니즘입니다.

---

## system call이란?

프로그램이 시스템 호출을 하는 것은 운영 체제가 자신을 대신하여 특정 작업을 수행하도록 요청하는 것입니다. 시스템 호출을 통해 수행할 수 있는 작업의 예로는 입/출력 작업, 프로세스 관리, 메모리 할당 등이 있습니다.

시스템 호출은 사용자 프로그램이 제어되고 안전한 방식으로 시스템 하드웨어 및 리소스와 상호 작용할 수 있게 해주는 최신 운영 체제의 필수 구성 요소입니다. 운영 체제 커널은 시스템 호출을 통해 액세스할 수 있는 일련의 기능 또는 서비스를 제공합니다. 이러한 서비스는 사용자 공간에서 직접 액세스할 수 없으며 시스템의 보안과 무결성을 보장하기 위해 커널을 통해 액세스해야 합니다.

일반적으로 프로그램에서 시스템 리소스나 서비스에 액세스해야 하는 경우, 프로그램에서는 시스템 호출을 통해 운영 체제에 필요한 작업을 대신 수행하도록 요청합니다. 그러면 운영 체제는 요청된 연산을 실행하고 그 결과를 프로그램에 반환합니다. 시스템 호출은 시스템 프로그래밍의 기본 요소이며 운영 체제, 장치 드라이버 및 기타 시스템 수준 소프트웨어를 작업하는 개발자가 광범위하게 사용합니다.

시스템 호출은 운영 체제 커널에 대한 제어된 진입점으로, 프로세스가 운영 체제에서 서비스를 요청할 수 있도록 한다. 이러한 서비스에는 프로세스, 파일 시스템, 장치 또는 프로세스 간 통신과 관련된 작업이 포함될 수 있다. 

시스템 호출은 사용자 공간 응용 프로그램과 커널 간의 인터페이스 역할을 한다. 이 설정의 주된 이유는 보호. 커널 공간은 사용자 공간과 분리되어 있다. 시스템 호출을 통해 사용자 공간 프로그램은 직접 액세스 권한을 부여하지 않고 커널과 상호 작용할 수 있으며 이는 보안 위험이 될 수 있다.

예를 들어 프로세스가 파일을 읽거나 쓰려고 하면 시스템 호출을 한다. 그런 다음 운영 체제는 프로세스를 대신하여 작업을 수행하고 작업이 완료된 후에만 프로세스에 제어권을 반환한다. 이렇게 하면 프로세스가 기본 파일 시스템이나 하드웨어 세부 사항에 대해 알 필요가 없다. 이는 모두 운영 체제에서 처리된다.

시스템 호출의 정확한 목록과 기능은 운영 체제마다 다를 수 있지만 일반적인 시스템 호출 범주에는 다음이 포함.

1. 프로세스 제어: 프로세스 생성, 종료 및 종료하거나 프로세스 정보를 가져온다
2. 파일 조작: 파일을 열고 닫고 읽고 쓰고 검색하거나 파일 속성을 가져오고 설정
3. 장치 조작: 장치 요청, 장치 해제, 읽기, 쓰기, 재배치, 감지 또는 장치 연결 또는 분리
4. 정보 유지 관리: 시간, 날짜, 시스템 데이터, 프로세스, 장치 또는 파일 정보를 가져오거나 설정
5. 통신: 통신 연결 생성, 삭제, 메시지 송수신, 상태 정보 전송, 원격 장치 연결 또는 분리


## .so와 .a 파일의 차이는?

- .so와 .a 파일은 코드 재사용 및 모듈화를 위해 C 및 C++ 프로그래밍에서 사용되지만 목적이 다르고 상황에 따라 사용됨
1. .a 파일: 정적 라이브러리 파일이라고 한다. “.a” 확장자는 개체 파일 모음을 포함하므로 “아카이브”를 나타낸다. 정적 라이브러리를 링크하면 프로그램에서 사용되는 라이브러리 함수의 코드가 컴파일 시간에 링커에 의해 애플리케이션의 바이너리에 직접 포함된다. 이렇게 하면 실행 파일의 크기가 증가하지만 바이너리가 시스템에 설치되는 외부 라이브러리에 의존하지 않고 자체적으로 실행될 수 있음을 의미한다. 그러나 라이브러리를 변경하려면 전체 애플리케이션을 다시 컴파일하고 다시 링크해야한다.
2. .so 파일: 공유 라이브러리 또는 동적 라이브러리 파일이라고 한다. “.so”는 “공유 객체”를 의미한다. 공유 라이브러리를 링크할 때 링커는 라이브러리 함수의 코드를 바이너리에 포함하지 않는다. 대신, 이러한 함수가 일부 외부 라이브러리에 존재한다는 사실만 알린다. 실제 연결은 애플리케이션이 실행되는 런타임에 발생한다. 장점은 실행 파일의 크기가 작게 유지되고 여러 응용 프로그램이 동일한 라이브러리 파일을 공유하여 메모리를 절약할 수 있다는 것. 또한 함수의 서명이 변경되지 않는 한 라이브러리를 사용하는 응용 프로그램을 다시 컴파일하거나 다시 링크할 필요 없이 라이브러리를 업데이트할 수 있다. 그러나 시스템에 필요한 라이브러리가 없거나 라이브러리 버전이 호환되지 않는 경우 애플리케이션이 실행되지 않는다.

결론적으로 .a 파일(정적 라이브러리)은 더 크고 독립적인 바이너리로 이어질 수 있지만 .so 파일(공유 라이브러리)은 더 작고 더 유연하지만 종속성 의존적인 바이너리로 이어질 수 있다. 둘 사이의 선택은 프로젝트 및 배포 환경의 특정 요구 사항에 따라 달라진다.