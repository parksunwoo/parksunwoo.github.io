---
title: Python에서 온 개발자P, Java에서 온 개발자J
categories:
  - Dev
tags:
  - python
  - java
  - interpreter
  - compiler
  - tech stack
last_modified_at: 2022-12-05T23:00:00-00:00
---

## Python vs Java : 전쟁의 서막

---

새로운 프로젝트를 진행하려한다. 새로운 프로젝트를 진행할때 백엔드 언어를 어떤걸로 사용할지 정해야하는데

팀내에는 Python에 익숙한 개발자가 있고 Java에 익숙한 개발자가 같이 있다.

Python 개발자는 Python을 어떻게 옹호하고 또 Java의 약점을 어떻게 공격할 것인가

Java 개발자는 또 Python과 어떻게 싸울 것인가

프로젝트 메인 언어로 선정되기 위한 전쟁이 시작된다.

Python 개발자(이하 P) 와  Java 개발자 (이하 J)는 서로 만나기로한 미팅때까지

상대방 언어의 단점도 찾아야하지만 자신이 사용하는 언어의 강점이 무엇인지 또 약점이 무엇이고 그걸 개선하기 위한 어떤시도가 있는지에 대해서도 준비를 해야한다.

P는 Python에 관한 자료를 찾아보기 시작한다. P가 프로그래밍 언어로 Python을 사용하기 시작한건

이제 3년정도 되었지만 Python 을 책으로 공부해 본 적은 없다.

*파이썬(Python)은 1990년 암스테르담의 귀도 반 로섬(Guido Van Rossum)이 개발한 인터프리터 언어이다.*

Python 으로 검색했을때 나오는 문장이다

문장을 자세히 살펴보면 

1. 

Python은 1990년에 만들어진 언어로 이제 30년이 넘었다. 

2022년 11월 23일에 3.11 버전이 릴리즈 되었다

Python 2.0은 2000 년에 처음 릴리즈되었고, 최신 버전인 2.7은 2010년에 릴리즈되었다.

Python 3.0은 2008 년에 처음 릴리즈되었다.

Python3 에서 기본적으로 문자열은 Unicode 이고 Python2 에서 문자열은 ASCII로 저장하고 있음.

Unicode 로 저장하고 싶다면 “u”를 붙여야 함

Unicode 로 처리하는 것이 편리한가가 중요한 이유는 ASCII 보다 Unicode 가 훨씬 유용하기 떄문임

Unicode 문자열은 외국 언어, 숫자, 기호, 이모티콘 등을 모두 저장할수 있기 때문임

Python2 에서는 정수에 나눗셈을 하면 가장 가까운 정수까지 반올림 처리, 소수점이 있으면 반올림 하지 않음

하지만 Python3 에서는 소수점 뒤에 0을 붙일 걱정할 필요없게 반올림 해주지 않음

기본적으로 Python3 에서는 print 명령어가 print() 기능으로 대체되었음

예를 들어, Python2 에서는 print “hello” 지만 Python3 에서는 print(”hello”) 이다.

Python2 에서는 xrange 와 range를 모두 사용했지만, Python3 에서는 range만 사용

2.

귀도 반 로섬은 네덜란드 출신의 소프트웨어 엔지니어이다. 프로그래밍 언어인 파이썬을 개발한 것으로 유명하다. 
2005년부터 2012년까지 구글에서 일했으며, 2013년부터 2019년 10월까지 드롭박스에서 일하고 있었다. 
은퇴하였다가 2020년 11월 13일 MS에 다시 입사하였다.

**[파이썬 창시자 귀도 반 로섬 "최대 약점인 속도 4년 내 최대 5배 향상 예정"](https://zdnet.co.kr/view/?no=20210516130301)**

인터프리터 코드를 최적화하는 핫파이(HotPy)와 호이파이2(HoyPy2) 등을 참조해 속도를 개선하는 한편, 과도한 속도 개선으로 인해 언어 기반을 무너트리지 않도록 기준도 마련하고 있다.

위 기사 내용으로보아 구글, 드롭박스, MS와 같은 유명한 기업들이 python을 주요하게 사용하고 있으며

파이썬의 최대약점은 느린속도, 이를 개선하기 위한 프로젝트가 진행중임을 알 수 있다

3.

인터프리터 언어이다.

인터프리터 언어란 한 줄씩 소스 코드를 해석해서 그때그때 실행해 결과를 바로 확인할 수 있는 언어이다.

[https://wikidocs.net/13875](https://wikidocs.net/13875)

프로그래밍 언어는 컴파일링 언어와 인터프리터 언어로 나뉘는데

컴파일링 언어는 한 번에 컴파일링 하므로 “구조”가 중요하다. 그래서 “객체지향성 언어”가 발전

반면 인터프리터 언어는 명령어 한 줄씩 컴파일링 되기 때문에 명령어 한 줄 한줄이 중요할수 있음

markdown 형식의 Jupyter 같은 것이 개발되었음.

인터프리터는 한 줄 명령어 단위이므로 명령 한 줄이 <함수>인 경우가 많다. 인터프리터 언어를 “함수 언어”라 부르기도,  큰 틀에서 Linux의 bash 쉘이나 zsh 쉘 그리고 Windows의 cmd도 “인터프리터 언어”라 부르기도




## 파이썬은 왜 느릴까?

---

파이썬이 인터프리터 언어라서 느린 것일까? 한 줄씩 컴파일링 하는게 속도에 어떤 영향을 미치는 것일까?

아래에서는 파이썬이 느린 이유를 조금더 자세히 살펴본다

[https://medium.com/@cookatrice/why-python-is-slow-looking-under-the-hood-7126baf936d7](https://medium.com/@cookatrice/why-python-is-slow-looking-under-the-hood-7126baf936d7)

1. 파이썬은 정적이 아닌 동적 타입이다

```
/* C code */ 
int a = 1; 
int b = 2; 
int c = a + b;

# python code
a = 1
b = 2
c = a + b
```

예시에서는 파이썬과 비교할 컴파일된 언어의 표준으로 C 언어를 사용.

C 컴파일러는 시작할때부터 a와 b는 정수형이라는 것을 알고 있음, 정수형을 아는것만으로 메모리 상의 단순한 값에 두 개의 정수를 더하고 이를 다른 정수로 반환하는 루틴을 호출할수 있음

반면 Python 인터프리터는 1과 2는 개체라는 것만 알고 타입은 알지못함.

인터프리터는 타입 정보를 찾기 위해 각 변수의 PyObject_HEAD을 검사한 후, 두 타입의 적절한 덧셈 루틴을 호출

마지막으로 반환 값을 보관 유지하는 새로운 Python 개체를 만들고 초기화

동적 타이핑은 모든 작업에 더 많은 단계가 포함되어있다는 것을 의미

2. 파이썬은 컴파일 형식이 아닌 인터프리터 형식이다

 `컴파일러`

프로그래밍 언어로 쓰여 있는 소스 코드를 다른 언어로 변환(컴파일)하고 그 결과를 파일에 써놓는 프로그램

컴파일러에 의해 컴파일된 목적 파일은 **링크**(최종 실행 가능한 파일(.exe)로 연결하는 과정)를 통해 실행 파일을 만드는 과정인 **빌드** 를 거쳐 CPU가 실행 파일을 실행한다.

 `인터프리터`

인터프리터는 전통적인 의미에서 실행 전에 기계어로의 컴파일 과정을 거치지 않고 소스코드를 바로 실행하는 일종의 가상머신이나 실행 환경이다. 그러나 인터프리터 방식도 내부적으로 소스 코드를 기계가 이해할 수 있는 형태로 변환되어야 함

컴파일러와 다른 점은 코드를 한 줄씩 읽어들여 다른 중간 코드나 기계어로 변환해서 임시 파일(*.pyc)에 저장하고, 변환한 것을 바로 실행하는 프로그램

인터프리터 작동 방식을 하드웨어 관점에서 보면,

인터프리터는 기계어로 변환된 코드를 실행 파일로 작성하지 않고 Memory에 바로 로드시켜 실행

엄밀히 말하면 표준 파이썬 구현체(CPython)는 기계어 실행 파일을 생성하지는 않지만 **인터프리터 안에 컴파일러를 내장**하고 있다고 볼수 있음

 `장/단점`

컴파일러는 개발 편의성은 떨어지지만, 실행 속도는 빠름

컴파일러는 한꺼번에 컴파일을 하기 때문에 컴파일 시간은 오래 걸리지만 실행 단계에서 이미 기계어로 변환된 목적 파일을 실행만 하면 되므로 속도가 월등히 빠름

단점은 전체 코드를 컴파일 후에 에러를 알려주므로 수정이 용이하지 않다는 것. 수정 사항이 발생하면 다시 컴파일

인터프리터는 개발 편의성은 높지만, 실행 속도는 느림

바이너리 파일만 실행시키면 되는 컴파일러와 달리, 변환과 실행을 동시에 진행해야 하므로 프로그램 자체 속도는 느림

소스 코드 한 줄을 변환해서 바로 실행하기 떄문에 실행 시작 시간은 빠르지만 전체 실행 속도는 컴파일러가 훨씬 빠름

장점은 소스 코드를 한줄씩 실행하므로 에러를 바로 알려줘서 실시간 코드 수정이 가능

3. 파이썬의 개체모델은 비효율적인 메모리 액세스가 발생할 수 있다.

이제 많은 정수들을 가지고 있고, 그것들을 가지고 어떤 종류의 일괄작업을 한다고 가정.

C에서는 어떤 종류의 버퍼 기반의 배열을 사용하는 동안, 파이썬에서는 표준 List 개체를 사용할 수 있음

가장 간단한 형태의 Numpy 배열은 C의 배열과 유사한 파이썬 개체. 이 배열은 **값들의 연속되는 데이터 버퍼를 위한 포인터**를 가지고 있음. 달리 말하자면, 파이썬 리스트는 **포인터의 연속되는 버퍼를 위한 포인터**를 가지고 있음.

각각의 포인터들은 그것들의 데이터(지금의 경우는 정수) 주소를 가지고 있고 그것들을 가르키고 있음.

Numpy 레이아웃은 저장과 액세스 측면 모두에서 파이썬의 레이아웃보다 훨씬 더 효율적


 `결론`

파이썬은 느리다. 느린 큰 이유중의 하나는 내부적으로 간접적인 타입이기 때문이다.

이 내부간접 타입은 개발자에게는 파이썬을 빠르고, 쉽고, 재미있게 만들어준다. 

파이썬 속도 개선을 위한 귀도 반 로섬이 진행중인 프로젝트는?

파이썬 3.11에서 가장 크게 개선된 것은 **적응형 인터프리터의 특화**다

객체의 형식이 거의 변경되지 않는다는 점에 착안해서 이제 인터프리터는 실행 중인 코드를 분석해 일반 바이트코드에서 형식별 바이트코드로 대체시도. 예를들어 더하기, 뺴기 등의 이진 연산을 정수, 부동소수점, 문자열을 위한 특화된 버전으로 대체할 수 있음

파이썬 3.11에서는 파이썬 함수 호출에 필요한 오버헤드도 줄었다. 함수 호출을 위한 스택 프레임이 더 효율적으로 설계되면서 메모리 사용량이 줄었다. 또한 재귀 호출은 꼬리 최적화는 되지 않지만  이전 버전에 비해 효율성이 개선. 파이썬 인터프리터 자체의 시작 속도가 더 빨라졌고 파이썬 런타임에 필요한 코어 모듈의 저장과 로드 효율성이 좋아졌다.

Python 끝.




---

J는 컴퓨터공학을 전공하고 C부터 배우기 시작해서 현재는 Java를 주로 사용해 개발을 하고 있다. 
J는 Java를 능숙하게 사용하고있지만 Python 은 사용해보지 않은 언어라 Java의 특징을 간단히 정리하면서 Python과 비교해보려고 한다.

[https://edu.goorm.io/learn/lecture/12243/한-눈에-끝내는-자바-기초/lesson/534737/자바란](https://edu.goorm.io/learn/lecture/12243/%ED%95%9C-%EB%88%88%EC%97%90-%EB%81%9D%EB%82%B4%EB%8A%94-%EC%9E%90%EB%B0%94-%EA%B8%B0%EC%B4%88/lesson/534737/%EC%9E%90%EB%B0%94%EB%9E%80)

Java 는 1995년 미국의 ‘썬마이크로시스템즈’라는 회사에서 개발한 객체지향 언어이다. 현재는 ‘썬마이크로시스템즈’가 엔터프라이즈용 DB로 유명한 회사 ‘오라클’에 인수가 되었고, 그 이후 Java는 ‘오라클’ 사에 의해 배포되고 있음

처음에 Java는 가전제품 내에서 동작하는 임베디드 프로그램을 위한 언어로 썬 마이크로시스템즈 사의 제임스 고슬링 팀에 의해 개발.

일반적으로 Java라 하면 프로그래밍 언어로 많이 알려져 있으나 개발 플랫폼에 더욱 가깝다.

J2SE(Java 2 Standard Edition), J2EE(Java 2 Enterprise Edition), JRE(Java Runtime Environment), JDK(Java Development Kit) 이와 같은 용어들은 모두 자바 플랫폼을 사용한 개발 혹은 실행을 위한 API 라고 말할 수 있음. 자바를 활용하여 개발을 하기 위해서는 본인이 어떤 종류의 개발을 할 것인지 잘 판단하여 적절한 API를 사용하는 것이 필요

Java의 특징으로는

1. 쉬운 난이도
    
    Java는 C와 C++ 의 문법을 차용한 언어이나 가장 이해하기 어려운 수준인 포인터, 다중 상속 등의 개념을 없애 문법적인 난이도를 낮췄음
    
    *Java와 C/C++을 비교했을 때는 Java가 쉬운 난이도는 맞지만 Java와 Python 을 비교했을때는*
    
    *Python은 변수의 데이터 유형을 직접 지정하지않고 자동으로 결정, 괄호와 세미콜론을 사용하지 않고
    들여쓰기 규칙을 따르는 방식으로 작성되어 읽기 쉽고 이해하기 쉽다.*
    
    *유명한 프로그래머인 에릭 레이먼드(Eric Raymond)는 파이썬을 공부한 지 단 하루 만에 자신이 원하는 프로그램을 작성할 수 있었다고 한다. Java와 비교했을때 Python이 학습 난이도는 낮다고 볼수있겠다.*
    
    > 프로그래밍 경험이 조금이라도 있다면 파이썬의 자료형, 함수, 클래스 만드는 법, 라이브러리 및 내장 함수 사용 방법 등을 익히는 데 1주일이면 충분하리라 생각한다.
    > 
    
2. Garbage Collector
    
    컴퓨터는 메모리라는 어떤 저장 공간을 가지고 있음. 프로그래밍을 할 때 역시 메모리에 다양한 데이터 값을 넣고 삭제하는 작업을 하면서 메모리가 지저분해지는 경우가 발생. Java에서는 Garbage Collector 라는 자동 메모리 정리 기능을 사용. GC는 프로그램이 실행 중에 사용하지 않는 메모리를 자동해제. 이 기능 덕분에 개발자는 메모리 관리를 염두에 두지않고 프로그램을 개발할 수 있음
    
    [https://qr.ae/pvfca0](https://qr.ae/pvfca0)
    
    a.
    
    *Python은 참조 카운팅이라고 하는 신뢰할수 없고 훨씬 느린 접근법을 사용*
    
    *속도가 느린 이유는 개체를 참조하고 취소할 때마다 인터프리터/VM 이 카운트가 0으로 낮아졌는지 확인해야하기 때문이다. 이것은 시간이 많이 걸리고 순환 참조 문제를 해결할 수 없기 떄문에 신뢰할 수 없다.*
    
    *한가지 주목할 점은 자바와 달리 dead object 가 즉시 제거된다는 점. 이 동작을 수행하는 데 훨씬 적은 메모리를 사용한다.*
    
    [https://dc7303.github.io/python/2019/08/06/python-memory/](https://dc7303.github.io/python/2019/08/06/python-memory/)
    
    Python은 내부적으로 malloc() 와 free()를 많이 사용하기 때문에 메모리 누수의 위험이 있음
    메모리를 관리하기 위한 전략으로 레퍼런스 카운트를 사용
    
    레퍼런스 카운트 전략이란 Python의 모든 객체에 카운트를 포함하고 이 카운트는 객체가 참조될 때 증가, 참조가 삭제될때 감소시키는 방식. 카운터가 0이 되면 메모리 할당 삭제
    생성 직후 레퍼런스 카운트 2가 출력되는 이유는?
    
    getrefcount()의 파라미터값으로 임시 참조되기 때문에 1이 아닌 2가 출력된다.
    
    Python은 기본적으로 레퍼런스 카운트를 통해 메모리를 관리. 레퍼런스 카운트는 메모리 관리에 매우 효율적으로 동작하지만, 레퍼런스 카운트만으로 메모리를 관리했을때 약점이 있음.
    
    순환 참조란 간단하게 컨테이너 객체가 자기 자신을 참조하는 것을 말함. 자기 자신이 참조될 때 프로그래머는 할당된 객체를 추적하기 어려워지고, 이때 메모리 누수가 발생할 수 있음.
    
    변수에 새로운 값을 할당해도 프로퍼티에 자기 자신을 참조하고 있어 레퍼런스 카운트가 남아있기 때문에 이런 현상이 발생. 이렇게 되면 레퍼런스 카운트가 0에 도달할 수 없고 할당된 메모리를 삭제할 수 없어 메모리 누수 발생. Python은 이 문제를 가비지 콜렉션으로 해결
    
    가비지 콜렉션은 General Hypothesis 라는 가설을 기반으로 작동.
    
    이 가설은 ‘대부분의 객체는 생성되고 오래 살아남지 못하고 곧바로 버려지는 것’ 과
    
    ‘젊은 객체가 오래된 객체를 참조하는 상황은 드물다’는 2가지 가설
    
    이 가설을 기반으로 메모리에 존재하는 객체를 오래된 객체와 젊은 객체로 나눌수 있는데, 대부분의 객체는 생성되고 곧바로 버려지기 때문에 젊은 객체에 비교적 더 많이 존재한다고 볼수 있음
    
    Generational Hypothesis를 기반으로 작동한다는 것은 젊은 객체에 대부분의 객체가 존재하니, 가비지 컬렉터가 작동 빈도수를 높여 젊은 객체 위주로 관리해주는 것
    
    가비지 컬렉터는 내부적으로 generation(세대)과 threshold(임계값)로 가비지 컬렉션 주기와 객체를 관리
    
    0세대의 경우 메모리에 객체가 할당된 횟수에서 해제된 횟수를 뺀 값,  즉 객체 수가 threshold 0 을 초과하면 실행. 0세대 가비지 컬렉션이 일어난 후 0세대 객체를 1세대로 이동시킨 후 카운터를 1 증가시킨다.
    
    이 1세대 카운터가 threshold 1을 초과하면 그 때 1세대 가비지 컬렉션이 일어난다.
    

    b.

    *반면에 자바는 기본적으로 모든 ‘도달 가능한’ 코드를 확인하는 CMS (Concurrent Mark Seep) 라는 훨씬 더 논리적인 접근법을 사용한다. 도달할 수 없는 것은 데드 코드로 표시.* 

    *JVM은 이러한 비활성 개체를 새 메모리로 이동하고 나중에 전체 메모리 영역을 한 번에 sweep 한다.*

    *파이썬과 달리 별도의 스레드에서 실행할 수도 있다. 파이썬보다 빠르지만 위의 모든 작업을 수행하기 위해 더 많은 메모리를 사용한다.*

    [https://d2.naver.com/helloworld/1329](https://d2.naver.com/helloworld/1329)

    stop-the-world란, GC를 실행하기 위해 JVM이 애플리케이션 실행을 멈추는 것. stop-the-world가 발생하면 GC를 실행하는 쓰레드를 제외한 나머지 쓰레드는 모두 작업을 멈춘다. GC 작업을 완료한 이후에야 중단했던 작업을 다시 시작. 어떤 GC 알고리즘을 사용하더라도 stop-the-world 는 발생한다. 대개의 경우 GC 튜닝이란 이 stop-the-world 시간을 줄이는 것

    CMS GC는 stop-the-world 시간이 짧다는 장점에 반해 다음고 같은 단점이 존재한다

    - 다른 GC 방식보다 메모리와 CPU를 더 많이 사용한다
    - Compaction 단계가 기본적으로 제공되지 않는다.




3. JVM(Java Virtual Machine), 플랫폼 독립적이다

소스코드에서 프로그램으로 만들어지는 과정 중 컴파일링 이라는 과정을 거치게 되는데, 이는 사람에 친화적인 컴퓨터 언어를 운영체제 가 이해할 수 있는 기계어로 번역되는 과정을 지칭. 즉, 컴파일링을 거쳤을 때 Linux용 C 프로그램 소스코드는 Linux 기계어로, Windows용 C 프로그램 소스코드는 Windows 기계어로 번역되기 떄문에 서로 다른 운영체제에서는 사용할수 없음. (이런 소스코드의 언어를 Native Language 라고 하고 대표적인 예로 C언어가 있음)

Java는 JVM이 중간 다리 역할. 운영체제와 프로그램 사이에서 프로그램이 동작하고 있는 운영체제가 무엇인지 판단한 뒤 해당 운영체제의 기계어로 다시 번역해주기 떄문에 운영체제와 상관없이 프로그램을 실행할 수 있음.

Java의 실행 파일은 이진 코드(클래스) 파일이다. 따라서 Java 런타임이 설치된 시스템에서는 어디서나 Java 프로그램을 실행할 수 있다. 다만 실행을 위해 JVM을 거쳐야 하므로 다른 언어에 비해 실행 속도가 느려진다.

4. Java에 관한 수많은 참고 자료를 찾을 수 있음

[https://wikidocs.net/199](https://wikidocs.net/199)

5. 객체 지향적이다
    
    Object-Oriented Programming 이란, 프로그램(실제세계)를 객체(사물) 라는 기본 단위로 나누고 이 객체들의 상호작용을 기본개념으로 한다
    
    객체지향 프로그래밍은 프로그램을 유연하고 변경하기 쉽게 만들기 때문에 재사용성이 용이하며 대규모 프로젝트에서 많이 사용되는 방법론이다. 프로그램 개발과 유지보수가 용이하다는 점이 가장 큰 장점으로 꼽힌다
    
    객체지향의 4가지 특징으로는
    
    1) 추상화 : 공통된 속성과 행위를 추출.  
    
    2) 캡슐화 : 연관있는 변수와 메소드를 묶어주는 작업. 접근 제어 지시자(public, private, protected) 를 통해 외부로부터의 접근을 제한하여 객체내에서만 접근이 가능하도록 해주며 이를 정보은닉이라 한다
    
    3) 상속 : 부모클래스의 속성과 기능을 이어받아 사용하는 것
    
    4) 다형성 : 프로그래밍 언어의 자료형 체계의 성질을 나타내는 것으로 동일한 변수, 함수명 등이 다양한 방법으로 기능하는 것을 말함, 오버라이딩, 오버로딩이란 형태로 제공
    
    Python 과 Java는 모두 객체지향 프로그래밍 언어로 간주된다. 개발자가 클래스를 통해 데이터 개체를 만들수 있음을 의미, 클래스는 본질적으로 모듈식이며 적은 코드로 많은 작업을 수행 할  수 있는 확장성이 뛰어난 프로그램이 가능하다.
    
6. 컴파일 언어인 동시에 인터프리터 언어이다.
Java는 먼저 텍스트 소스를 컴파일하여 2진 파일(클래스 파일)로 만든 다음 Java 런타임이 클래스 파일을 인터프리트하면서 실행한다. 먼저 시스템에 무관한 2진 파일을 만듬으로써 Java는 컴파일 언어에 가까운 속도와 시스템 독립성을 동시에 얻을 수 있다.

7. 멀티 쓰레딩을 지원한다
하나의 프로그램 단위가 동일한 쓰레드를 동시에 수행할 수 있음. Java는 멀티 프로세서 하드웨어를 지원하도록 설계되었으므로 멀티 CPU 시스템에서 높은 효율을 낼 수 있음.

[https://koreapy.tistory.com/677](https://koreapy.tistory.com/677)

Python은 동시다발적인 멀티쓰레드를 처리하거나 CPU에 집중된 많은 쓰레드를 처리하는데 적합하지 않다. 이는 바로 GIL (Global Interpreter Lock) 때문이다. 이 매커니즘은 한 번에 하나의 바이트 코드명령만 실행하도록 하는 것을 말하는데 프로그래머는 만들고자 하는 프로그램의 대부분을 Python으로 만들 수 있지만 시스템 프로그래밍이나 하드웨어 제어와 같은 매우 복잡하고 반복 연산이 많은 프로그램은 만들 수 없는 것이 그 이유이다.

Python은 자원배분을 한 쓰레드에게 할당한 후, 그 쓰레드가 끝날 때까지 Lock 을 걸어 다른 쓰레드가 접근하지 못하게 한다. GIL은 멀티쓰레드 프로그램에서 성능이 떨어지게 하지만 Python을 포함한 많은 인터프리터 언어는 GIL을 사용하고 있음. 그 이유는 GIL을 이용해서 멀티쓰레드를 구현하는 것이 parallel 한 멀티쓰레드를 구현하는 것보다 훨씬 쉽기 때문이다. 

GIL을 도입하면 인터프리터의 구현이 쉬워지고 Gabage Collector 만들기도 좋으며 C/C++ 확장 개발에 용이하기 때문에 Python을 많이 사용하고 있다. 또한 프로그램이 I/O를 많이 쓰면 대부분 I/O bound 이기 때문에 Python의 쓰레드를 사용하는 것이 좋은 경우도 있음.

Python 에서 병렬작업은 안되나요?

아니다. 병렬작업을 하기 위해선 쓰레드 대신 프로세스를 만들어주는 라이브러리 Multiprocessing 모듈을 사용. Multiprocessing 모듈은 쓰레드 대신 프로세스를 띄워준다. 하나의 Interpreter 를 쓰는게 아니라 여럿의 프로세서를 구동시키는 것. 이 경우 프로세스 관리는 Python 에서 하는 것이 아니라 OS에서 하는 것이기 때문에, OS에서 적절하게 프로세스를 코어별로 할당하게 해서, 전체적으로 스피드를 올려주게 된다.

8. 예외처리가 잘 되어 있지만, 개발자가 일일이 처리를 지정해 줘야 한다는 불편함

9. 다른 언어에 비해 작성해야 하는 코드의 길이가 긴 편

아래 그림과 같이 같은 “Hello, World!!” 를 출력하기 위해 작성해야 하는 코드 길이를 비교해보면
Java의 경우가 더 길다.

![print hello world](/assets/images/print-hello-world.png)

[https://www.slideshare.net/ChrisCho2/python-vs-java-pycon-korea-2017](https://www.slideshare.net/ChrisCho2/python-vs-java-pycon-korea-2017)

Java 끝.




## 그럼 어떤 언어를 선택해야할까?

---

[https://ciksiti.com/ko/chapters/2644-python-vs-java-for-developers-comparison--linux-hint](https://ciksiti.com/ko/chapters/2644-python-vs-java-for-developers-comparison--linux-hint)

Python과 Java는 다양한 종류의 응용 프로그램에서 전 세계적으로 널리 사용된다. 

Python은 기계 및 딥러닝과 관련된 응용 프로그램에서 사용되는 언어.

Tensorflow, Keras, PyTorch 등과 같은 라이브러리 및 프레임워크는 사용자가 자유롭게 실험할 수 있게 함

반면에 Java는 하드웨어와 소프트웨어가 결합된 임베디드 시스템에서 널리 사용됨. 
Java는 Android 개발에도 사용된다. 

[https://wikidocs.net/115269](https://wikidocs.net/115269)

스타트업에서 필요한 스택과 SI에서 필요한 스택은 전혀 다르다

대부분의 스타트업은 자체 서비스를 만들기 위한 개발을 한다. 더 오래 갈 수 있는 단단한 코드를 만드는 데 신경을 많이 쓴다. 만든 사람이 유지 보수해야 하기 때문이다.

따라서 코드에 업무 도메인이 가능한 한 많이 녹아있는 형태로 만든다.

Python 이나 Nodejs 등 스크립트 언어를 많이 쓰는 것도 수정해야 할 때 코딩양을 줄이기 위해서이다.

ORM을 쓰는 것도 언제 데이터베이스가 변경될지 모르기도 하고, 도메인 객체를 코드로 표현하기 위함

따라서 스타트업에게 데이터베이스는 그냥 저장소고, 업무는 코드에 녹아있음

결론적으로 스타트업은 스크립트 언어 + 아무거나 DB(NoSQL 무관) + 좋은 설계 + 최신 프레임워크를 중요시

SI 는 Java (Spring) + 안정성 높은 DB (RDBMS 한정) + 좋은 쿼리 작성 능력 + 안정된 프론트엔드 솔루션을 중요시한다.